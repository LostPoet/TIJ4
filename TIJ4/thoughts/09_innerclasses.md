# Inner Classes

## 正常内部类(在外部类定义之中)

1. 只有在包含内部类的外部类的非静态方法中, 内部类类型名可以直接使用, 其它地方都需要完整类名, 格式:*OuterClassName.InnerClassName*
2. 与外部类的域和方法**互通**, 即使是私有内部类
3. 内部对象依赖于外部对象, 除非是嵌套的内部类(声明为static)
4. 内部类可以被声明为private或protected(一般外部类仅能被声明为public或package access)
5. 私有的内部类可以很好地隐藏实现, 类名对其他外部类不可见, 同时与内部类共享信息, 可通过一个方法创建并返回私有内部类对象实现在外部调用内部类代码, 即外部看到的仅仅是接口

## (在方法或其范围内的)本地内部类

 1. 前面的正常内部类可以被改写, 存在于在方法或任意区域内, 这样做的动机有两个(注意匿名内部类也适用):
    * 想获得一个interface的实现对象, 使用内部类实现并返回引用
    * 解决复杂问题时想要创建一个非公有的类来提供帮助
 2. 作用域仅限方法定义之内
 3. 仅能够读取方法内的final变量
 4. 避免和外部的类产生命名冲突, 即外部不具有访问本地内部类类名的权限
 5. 即使在选择分支中定义的类也会正常被编译
 6. 什么时候选用本地内部类而不是匿名内部类?
    * 需要构造函数
    * 需要创建不止一个该类的对象

## 匿名内部类

 1. 匿名内部类相当于是在创建对象的那一刻定义类, 这是其本质, 也是基本用法
 2. 参数如果是外部对象的引用必须用final
 3. 内部域要么在定义时初始化, 要么用instance initialization
 4. 如果发生了继承, 只能实现一种类或接口, 并且有隐含的upcast
 5. 匿名内部类的构造函数如果继承类, 基类只有非默认的构造函数, 注意如何传参
 6. 相较于本地内部类, 匿名内部类使得代码更加紧凑, 适合则用

## 嵌套内部类

1. 嵌套内部类和外部对象之间无连接, 不需要创建外部对象便能单独创建嵌套内部类, 但同时嵌套内部类无法直接访问外部的非静态成员(因为static区域内无对象)
2. 普通内部类一定是非静态区域(因为有对象链接), 所以无法拥有static域和方法, 也不能拥有嵌套内部类, 嵌套内部类则都可以拥有

### interface中的类

1. interface中的类隐式声明为public和static, 这种内部类甚至可以实现包围它的interface
2. 这种内部类仅仅是将名字放在了interface内部, 具有相对独立性, 本身对interface没有任何特殊的访问权限(interface成员都是public), 只是被用来提供一些有用的功能, 同时interface的实现者也不需要对此内部类做任何额外操作

### 普通内部类的嵌套

1. 不管嵌套多少层, 内层的类总是能够访问外层的成员, 即使是私有成员

## 内部类的设计考量

1. 内部类可以打破外部类只能继承一个类的限制, 和interface一起构成了多重继承的两个重要方面
2. 讨论几个情况:
   * 有两个或以上的待实现的interface, 可以直接用外部类多重继承, 也可以结合内部类进行实现, 这两种方法没有孰优孰劣之分, 根据情况选用
   * 有两个或以上的待继承的类或抽象类, 必须使用内部类来实现
   * 如果没有多重继承的硬需求, 可以不使用内部类, 但内部类还有一些有用的特性:
      * 内部类对象本身可以保留自身的信息, 并且这些信息独立于外部类对象的信息
      * 可以用内部类实现或继承同一个接口或类, 然后不同内部类代表一种不同的实现方法, 整合在同一个外部类中
      * 内部类对象的创建并不和外部类对象的创建绑定, 也即创建外部类对象时并不一定要创建内部类对象
      * 没有"is a"关系, 内部类是一个相对独立的实体

### 闭包 & 回调

1. 闭包指一个能够保持原有信息的可被调用的对象, 内部类就是一种闭包, 它不仅保有自身的信息, 同时还能够访问原对象的任意成员
2. 回调指使用另一个对象含有原有对象信息, 并能够在另一时间通过这些信息来调用原对象, 更通俗一点, 回调是在特定时机下运行特定的函数, 通过**指针**或**实现了接口的闭包**能够实现回调, Java中的闭包更加灵活和安全, 因为外部接口限制了能够被调用的方法
3. 闭包是方式, 回调是目的, interface是桥梁(这个桥梁也可以是λ表达式, 关键是传入方法), 闭包提供了一个安全的钩子(interface类型的引用), 外部只能调用interface里的方法, 因此钩子的安全性得到了保障, 回调类扮演指针的角色, 用其中包含的引用完成回调(回调可以不使用闭包, 直接使用外部类, 回调本身也可以不被使用, 直接使用引用, 但显然闭包和回调的结合提供了便利性)

### 用内部类实现控制框架

1. 几个关键词:
   * *application framework*: 为解决特定问题而设计的类的集合, 这些类可被继承并覆写, 被覆写的部分可被自定义
   * *template method pattern*: 模板方法为不变部分, 覆写方法为可变部分
   * *control framework*: 一种为回应事件的application framework
   * *event-driven system*: 回应事件的系统
2. 用于执行"ready"状态的控制框架剖析:
   * Event抽象类: 被控制的基本对象, start()属于构造函数一部分, 独立出来可以用于其他Event控制Event本身, ready()用于判定是否处于准备状态, action()唯一抽象方法决定了具体的行为
   * Controller类: 包含List\<Event>执行队列, addEvent()用于向队列中添加事件, run()遍历队列执行已就绪事件, 完毕后将其从队列中移除
   * 以上两个类构成了基本的控制框架体系, Event抽象类负责接口部分, Controller类属于实际的控制框架, 他们都描述了控制框架中不变的部分
3. GreenhouseControls类:注意Bell和Restart内部类, Bell的action()新建一个Bell对象并插入到执行队列中, Restart的构造函数不仅执行start()设定就绪时间, 并且将自身的eventlist插入到执行队列中, action()对当前eventlist以及Restart本身重新执行start(), 并添加到执行队列, 注意这个过程中不新建Event对象
4. *command pattern*: 执行一系列请求, GreenhouseController类很好地体现了这种设计模式

## 内部类与继承

1. 由于内部类对象依赖于外部类对象, 要注意**从外部**继承内部类构造函数的特殊格式:
   * enclosingClassReference.super(*constructor args*)
2. 当**仅**继承含有内部类的外部类时, 内部类并不会被覆写, 新定义的内部类(即使同名)也是存在于各自的命名空间内
3. 想要覆写内部类, 就要明确指出继承关系

## 练习题

| 题号  | 描述                                         |
| :---: | -------------------------------------------- |
|1|创建并初始化内部类对象的引用|
|2|Sequence类使用内部类实现了外部接口, 此题是应用Sequence类的一例|
|3|内部类可以对外部类的私有成员进行访问|
|4|.this返回外部类对象的基本用法|
|5|.new借助外部类对象创建内部类对象的基本操作, 省略了构造函数名的冗余|
|6|即使在不同包中, 继承的protected类型的内部类依旧可见, 但要注意构造函数的可见性|
|7| 内外部类的私有成员互通|
|8|内外部类的私有成员互通|
|9|方法中包含内部类|
|10|方法的区域中包含内部类|
|11|内部类对除包含它的其他的外部类是不可见的, 因此也就无法downcast|
|12|第7题的匿名内部类实现|
|13|第9题的匿名内部类实现|
|14|匿名内部类可以省去繁琐的命名定义过程, 直接在需要对象时定义类|
|15|在父类只有非默认构造函数时如何传参|
|16|匿名内部类实现工厂方法|
|17|匿名内部类实现工厂方法|
|18|嵌套内部类的定义与创建其对象|
|19|内部类与嵌套内部类再进行重复嵌套的对比|
|20|interface内的类与interface的相对独立性|
|21|interface内的类的有用性, 匿名内部类实现接口|
|22|内部类对同一个interface的不同实现|
|23|匿名内部类实现interface, 用另一个容器类进行操作|
|24|直接向GreenhouseController类添加新的内部类|
|25|通过继承向GreenhouseController类添加新的内部类|
|26|内部类继承时调用基类带参数的构造函数|
