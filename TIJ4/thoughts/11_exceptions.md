# Error Handling with Exceptions

## 概念

1. 在C及一些早期语言中, 会用返回值或者设置flag等方式进行错误处理, 这种做法有两个弊端:
   * 程序员有过度自信倾向, 因此往往在该检查时不进行检查
   * 在每个需要检查的地方都进行检查, 影响代码可读性
2. 引入统一的错误处理方式能够解决上述问题, 这样的异常处理机制有三大优点:
   * 统一的形式带来的便利性使得程序员愿意使用这种方式来处理异常
   * 提供了一种"脱离"机制, 因为当前的上下文解决不了异常, 只能在更高层次进行解决, 这种机制将正常的代码与异常处理的代码分离, 提高了可读性
   * 统一的处理方式能够使许多异常被集中在一处解决, 降低了代码重复

## 基本异常

1. 抛出异常是异常处理的开端, 大概发生三件事:
   * 在堆中**new**一个新的异常对象
   * 停止当前程序的执行, 并弹出异常对象的引用, 在这一点上, 有点类似于return语句离开方法的过程, 但抛出异常甚至能够脱离scope
   * 为异常对象寻找合适的异常处理程序(*Exception Handler*)

### 异常参数

1. 对异常来说,通常都有两个构造函数, 一个默认构造函数, 另一个以String类型作为参数, 传递附加异常信息
2. Exception类型的基类是Throwable, 一般来说异常信息存在于异常对象内部, 以及异常类的类名之中, 后一种在大多数情形下都够用了
3. Throwable和Exception的JDK文档:
   * [Throwable](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Throwable.html)
   * [Exception](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Exception.html)

## 捕获异常

1. **try**语句块:
   * 含义: 尝试捕获区域内的方法所抛出的异常
   * 在该语句块内, 即使有其他方法抛出了异常, 也不会直接逃离当前方法
   * 如果没有try语句块, 那么即使是相同的方法, 也必须加上错误检测的包装方法, 十分麻烦
2. **catch**语句块:
   * 这里即是异常处理程序(*Exception Handler*)
   * 必须与**try**语句块结合来使用, 紧跟其后
   * 作为参数的异常即使没有被使用也得放在那里, 说明该**catch**语句块处理了哪个异常
   * 对于多个**catch**语句块, 会顺序查找第一个完成匹配的块, 后续的块就被忽略
   * 可能存在多个方法抛出相同的异常, 但只用一个块就能搞定, 再次体现了统一异常处理的便捷性

### Termination vs. Resumption

1. Termination: 认定该异常很严重, 以至于无法返回异常抛出的地方重新执行, 这是Java默认支持的
2. Resumption: 假定在执行修复之后, 从异常抛出地程序可以重来, Java内部本身不支持这种做法, 但有两种途径可以加以实现:
   * 自已定义一个方法, 并在异常发生时执行该方法
   * 在**try-catch**语句块外部包裹循环语句
3. Resumption不被支持的原因:异常可能在任意位置被抛出, 而Resumption的关键是确定抛出地, 要针对每个抛出地编写不同的解决代码不现实

## 创建自定义异常类

1. 继承已存在的相似度最高的异常类, 命名要体现自定义的特点
2. 异常信息System.err取代System.err
3. printStarkTrace()是定义在Throwable类中的方法, 其一种重载参数为System.err, System.out对应类型
4. 自定义的异常类和普通类有共同之处, 可以在其中创建私有域, 重载构造函数, 覆写父类方法等, 但这些"额外操作"在用户端可能会被忽略, 因为外部使用异常的最普通场景就是: 简单地抛出此异常(而不使用try-catch语句块进行处理)

### logging

1. 库: java.util.logging
2. exceptions/logging.java中:
   * 静态方法logger.getLogger()创建Logger对象, 该对象信息默认送System.err
   * 注意LoggingException类的构造函数如何将异常信息写入logger

## 异常声明

1. 提供了一种通知用户处理异常的机制, 不用翻看源码便能明确方法所抛出的异常
2. 至此, 异常在编译阶段的一致性和正确性便得到了保证, 对于每个被抛出的异常, 有两种情况能通过编译:
   * 处理了该异常
   * 没有处理该异常, 并进行了异常声明
3. 有一种情况可以欺骗编译器: 一方法声明抛出了某异常, 但实际并没有抛出, 这种做法有两点好处:
   * 可作为异常的一个"容器", 后续抛出对应异常时无需修改方法的其他部分
   * 便于创建需要抛出异常的抽象类或interface
4. 在编译阶段被检查和确认的异常被称为*Checked Exceptions*

## 捕获任意异常

1. 想要捕获任意异常只需catch所有异常的父类Exception(也有其他类可作为异常的父类), 而且此语句要放在catch块的末端
2. Throwable的主要方法梳理:

    ```java
    // 获取细节信息, 或是在一个区域内的信息
    String getMessage();
    String getLocalizedMessage();

    // 返回Throwable的简短描述, 如果有细节信息, 则包含之
    String toString();

    // 打印Throwalbe和Throwable的调用栈, 默认版本打印到标准错误流
    void printStarkTrace();
    void printStarkTrace(PrintStream);
    void printStarkTrace(java.io.PrintWriter);

    // 记录当前调用栈信息到Throwable对象中, 在重新抛出异常时很有用
    Throwable fillStarkTrace();
    ```

3. 另外, Object类型的一些方法也很有用: `getClass()`返回代表该类的对象, `getName()`返回包括包信息的名称, `getSimpleName()`返回简单名称

### 调用栈

1. `getStarkTrace()`方法返回一个StarkTraceElement类型的数组, 第一个元素为栈顶, 也即最后一个被调用的方法, 这样一来, 顺序打印数组便正好得到一个从栈顶到栈底的结果(调用顺序从下至上)

### 重新抛出异常

1. 在catch块中重新抛出已捕获的异常有两点需要注意:
   * 跳出了当前的上下文, 进更高一级的异常处理
   * 保留原有的异常信息
2. 如果想要更新后的异常信息, 那么需要在抛出时调用`fillInStarkTrace()`方法写入新的信息(因为该方法返回Throwable, 所以记得downcast到Exception类型或其子类)
3. 当抛出的异常不是所捕获的异常时, 被捕获的异常信息并不会记录在抛出的新异常中, 就类似于调用了`fillInStarkTrace()`方法

### 异常链

1. 当想要重新抛出的新异常记录原始信息时, Throwable类中有一个cause域(类型为Throwable)用来存储原异常信息, 有两种途径可以对该域进行修改:
   * 带cause参数的构造函数(主要指Error, RuntimeException, 及Exception)
   * 调用`Throwable initCause(Throwable cause)`方法
2. exceptions/DynamicFields.java:
   * `Object setField(String id, Object value)`方法展示了两种设置异常链的方法, 该方法在输入不存在的id时可以自动创建新的条目
   * 引起DynamicFieldsException的原因就是输入了null作为value参数, 这里用到`initCause()`十分典型
   * `getField()`方法抛出的的NoSuchFieldException对用户来说是需要进行处理的, 但是在`setField()`中, 遇到不存在的id会调用`makeField()`, 因此这里的NoSuchFieldException意味着编程错误, 需要包裹运行时异常抛出

## 标准Java异常

1. Throwable描述了所有可被抛出的异常, 它有两个重要子类: Error和Exception, Error代表编译时以及系统错误, 这类错误一般不需要被捕获, Exception是能够被Java标准库方法和用户自定义方法抛出的异常的父类, 因此最常被打交道的就是Exception
2. 一些Java标准库会定义自己的异常体系, 如java.io.IOException

## 运行时异常

1. RuntimeException的父类是Exception, 同时自身是所有运行时异常的父类, 这类异常叫做*Unchecked Exception*
2. 运行时异常一般代表出现了bug, 会被自动抛出(有时候需要自行抛出), 并发送异常信息到System.err, 不用被方法所声明, 也不用进行处理
3. bug要么是无法预知的差错(如引用空指针), 要么是程序员自身的疏忽(如没检查数组越界), 因此Java的异常处理不仅仅用来解决那些无法被当前上下文处理的异常(*Checked Exceptions*), 并且能够帮助发现bug(*Unchecked Exception*)

## 用finally块进行清除

1. finally块一定会被执行

### finally块的意义

1. 在没有垃圾收集器和自动销毁方法的语言中, finally块是确保内存释放的重要手段, 在Java中, finally块被用于将程序的执行后的状态复原到执行前(不包括内存)
2. 如果没有finally块, 清除操作将会变得十分复杂(要在不同情况下进行清除), 且效果不好
3. finally块的发生时间在当前一级的catch结束之后, 在下一级的catch开始之前

### 在return时使用finally

1. 在一个方法有多个地方需要return时, finally能确保一些操作必然被执行

### 坑: 丢失的异常

1. 核心在于第二次抛出的异常或是程序控制语句在第一次抛出的异常得到处理之前, 覆盖掉了它
2. 在finally块内抛出异常或是进行return都有可能引起此问题

## 异常的限制(覆写时)

1. 当覆写父类方法时, 异常只少不多, 这样能够确保使用父类方法的代码将来替换为子类方法时不会出现问题(保证了父类对象可替换)
2. 子类的构造函数可以添加异常, 但必须声明父类相应构造函数的异常, 并且子类构造函数不能处理任何父类声明的异常
3. 子类一般方法(不抛出任何异常的方法)需要和父类保持一致
4. 当继承和interface的方法名一样但抛出了不同异常时, 继承的优先级更高, 所以这种情况下interface中定义的方法不能再添加额外的异常
5. 即使父类方法抛出了异常, 子类方法也可以选择不抛出异常, 或仅仅抛出一部分异常
6. 覆写父类方法时, 还可以抛出具有相应继承关系的异常(可以想象, 编写针对父类方法的异常处理代码将会同样适用于子类)
7. 当发生了upcast时, 编译器会要求处理父类方法所抛出的异常而不是子类抛出的异常(子类可能少抛出或不抛出异常), 这样是正确的, 因为可以最大程度确保子类对象抛出的异常能够得到处理
8. 要注意异常声明并不是区分方法的标准(这个标准只包含方法名和参数表)

## 构造函数中抛出异常

1. 在构造函数中抛出异常需要十分小心, 因为很可能导致无法进行正确的清理, 这时finally都不管用, 因为可能在抛出异常时要被清理的对象甚至可能还没有得到完全的初始化
2. exceptions/InputFile.java:
   * 构造函数`InputFile(String fname)`: 展示了一种不能在finally块中进行清除的情况, 这时外部用到此类对象的方法需要进行合理的资源清除
   * `String getLine()`: 涉及到何时对异常进行处理的设计问题, 这里选择了将异常作为运行时异常进行抛出
   * `void dispose()`: 在InputFile类对象无用时需要调用此方法释放相应的资源, 这个方法体现了Java的一个缺点是用户必须自行处理所有的非内存资源
3. 当所使用的对象在构造函数中抛出异常时, 最安全的处理方法是使用嵌套的try语句块, 在每个具有非内存资源的对象(已成功创建)下面增加try-finally块(这一级也可能包含catch), 在finally块中进行清除, 保证资源的释放
4. 当某对象的构造函数不抛出异常但同样具有需要进行清理的资源时, 此对象下面也要使用try-finally块进行清理
5. 在一段区域内使用多个构造函数抛出异常的对象的情况最为复杂, 这时需要try语句块的多级嵌套, 因此构造函数中最好不要抛出异常

## 异常匹配

1. 顺序匹配, 父类能够匹配相应子类, 但将父类置于子类之前会引起编译错误

## 其他方法

1. "在你知道怎么处理之前, 不要处理异常"
2. *Checked Exceptions*有可能逼迫用户过早地处理一个异常, 从而导致用户不得不"吞掉"(catch后不进行任何处理)异常, 即使catch后打印调用栈信息, 那也意味着用户此时还不知道如何处理这个异常

### 历史

1. 在类C语言中, 每个函数调用都必须跟上检查其返回值的代码, 这会导致难以阅读的低效代码, 并且使得程序员们不乐意进行异常的处理
2. Java中的异常处理方式其实也有类似弊端, 但是减少了代码重复
3. C++区别于CLU的创新点是增加了异常声明, 其实质在于"忽略"异常
4. C++中的异常声明在编译时仅仅保证简单一致性(如保证重载或继承的方法也抛出相同的异常), 如果有违背声明的情形, 要到运行时才能被发现
5. C++由于具有模板, 异常声明并不常用, 而在Java中异常声明给泛型的使用增添了一些限制

### 观点

1. 关于*Checked Exceptions*:
   * 这是一个实验性的举动, 并且Java之后没有其他语言这么做
   * 类型检查对于小规模的程序有着显而易见的好处, 但是难以应对大规模的程序
2. 关于*Checked Exceptions*和静态类型检查带来的好处, 有两个观点:
   * 好处是一个统一的通过异常的错误报告模型, 而不管程序员是否被编译器逼迫这么做
   * 好处在类型被检查, 合适的类型被使用, 而不管发生在何时, 编译时或运行时均可
3. 上述观点意味着解放编译时的限制能够带来更高的生产力
4. 编译时查错比如自动构建过程和单元测试是有好处的, 但是并不能防止程序员写出垃圾代码
5. 在*Checked Exceptions*之外, 还有其他的解决方案

### 将异常送入控制台

1. 在main()方法中抛出Exception可以省略掉对方法内部异常的处理
2. 这种方法适用于比较简单的情形

### 将检查异常转换为非检查异常

1. 捕获检查异常后包装成运行时异常再抛出, 检查异常这时是作为运行时异常的cause
2. 当编写一般方法, 并且在*Checked Exceptions*发生时不想"吞掉"或是输出异常信息的情形下, 这种方法非常有用
3. 这样做在方法外部不用进行异常声明, 并且在想要处理异常时有办法通过`getCause()`进行追溯