# Polymorhpism

1. 多态是接口与应用实现分离的另一个维度, 实现了概念(*what*)与方法(*how*)的分离, 不仅增进了代码的组织与可读性, 更增强了代码的可拓展性, 尤其是需要添加新特性时
2. 封装实现了将特征与行为组合创建新的类型, 实现隐藏通过成员私有化将接口和实现分离, 多态则是在类之上实现分离, 通过继承可以建立类与类之间的联系, 父类提供公共的方法接口, 子类提供接口的不同形式, 多态便是通过公共接口实现不同形式
3. 多态的三个要素: 继承, upcast, override
4. 别名: *dynamic binding*, *late binding*, *runtime binding*

## 如果没有多态

1. 那么为了实现可作用于多种对象的某种方法, 只能通过overloading来为每一种对象所属的类创建方法

## 如何引发多态

1. 通过一个普通的方法调用, 该方法不能是static(无对象)和final(隐式包含private, 无继承)类别的方法, 且调用该方法所使用的对象引用要满足三个要素
2. 简而言之, 就是通过动态绑定方法触发多态

## 绑定

1. 当通过引用调用对象中的方法时, 编译器只能看到引用, 不知道具体指向哪一种对象(因为有upcast, 引用可能指向不同类型的对象), 无法做到多态, 要想理解多态, 需要先理解绑定, 即如何将函数体绑定给一个函数调用
2. 根据绑定发生的时间, 可分为两类:
   * *early binding*: 由编译器和连接器完成, 发生在程序执行之前
   * *late binding*: 由函数调用机制决定究竟执行哪一段函数体, 不同语言对这种绑定的实现可能不一致, 但必须有一些类别信息被写入对象中以供判断
3. 在Java中, 除了static和final(包含private)方法之外的方法都采用*late binding*, 因此*late binding*的实现不需要添加特殊语句, 对于这两种方法, 编译器可以决定其不需要使用*late binding*, 因此能够采取一定优化(省略方法调用的开销), 但对性能的影响十分有限

## 可拓展性

1. 可拓展性可以体现在两个维度, 一方面可以增加接口而不影响原有的接口, 另一方面可以向继承结构中**向下**添加类而不影响原有的继承关系

## 避免踩坑: 覆写私有方法, 覆写域和静态方法

1. 这三种情况在'覆写'时会产生类中各自独立的成员, 并不构成多态
2. 要注意避免重复命名

## 构造函数与多态

1. 第四章初始化和第六章继承已经把初始化的顺序大致讨论清楚, 这里主要谈动机
2. 构造函数的重要性体现在保证对私有成员的合理初始化上, 因为继承的关系, 子类需要正常使用父类接口, 但是只有父类构造函数知道如何初始化其私有成员以便确保接口的正常运行, 所以必须先将父类初始化
3. 对于类中域成员, 最好是在定义时进行初始化, 这样在构造函数之前就能确保父类对象得到了完全初始化**并且**自身的所有成员都得到合理初始化

### 继承与清理

1. 两个相反: 组成成员对象的清除顺序和创建时相反, 继承类对象的清除顺序和继承结构的初始化顺序相反, 两个相反解决了可能存在的依赖问题
2. 对于共享对象(同一对象被多个对象当作组件), 要使用引用计数法来进行合理的清除

### 多态方法内含于构造函数

1. 构造函数的视角中, 只能保证父类对象得到了初始化, 对于本对象中的成员, 则不能确保得到合理初始化
2. 初始化流程的最后一块拼图: 继承时, 父类(及可能产生的递归)的初始化发生在子类对象的存储空间分配完毕之后**以及**子类开始进行定义时初始化之前, 此时子类对象中域成员仅得到初始值, 没有被合理初始化, 并且父类已经掌握了子类的方法信息
3. 多态方法即使发生在父类构造函数中也能调用子类的相应方法, 这说明了此时程序已经得到足够信息, 能够判断发生了多态(和类的装入及静态初始化过程相关), 当然, 这种做法是错误的, 因为此时的子类还没有被合理初始化, 只是被分配了空间
4. 对构造函数, 要尽可能地使其少做事, 并且尽量不要在构造函数内调用当前类的方法, 唯一安全的方法是私有或final方法(因为无法继承, 不会产生多态)

## 一致返回值

1. 也即对于覆写的方法, 返回值类型之间也可以存在继承关系

## 继承设计

1. 可以用*state pattern*设计模式实现更加灵活的多态, 改变引用所指的对象, 一个指导是: 用继承体现不同行为, 用域体现不同状态

### 替换 还是 拓展

1. 用多态可以应对替换, 而对于拓展, 则需要downcast

### downcast和RTTI

1. 所有downcast在运行时都会被检查
2. RTTI提供了一种机制来取得子类的信息, 从而为downcast带来足够的判断参考

## 练习题

| 题号  | 描述                                         |
| :---: | -------------------------------------------- |
|   2   | 重申@Override用法, 明确覆写, 防止重载        |
|  10   | 在有多层方法调用时, 多态仍然能正确发生       |
|  13   | 复习finalize()确认关闭状态的用法             |
|  14   | 在有共享对象的情况下, 整个初始化与清除的过程 |
|  15   | 说明多态能发生在初始化完全完成之前的又一例   |
|  16   | state设计模式又一例                          |
