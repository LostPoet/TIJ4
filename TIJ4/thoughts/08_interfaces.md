# Interfaces

1. interface和抽象类提供了更加结构化的方式来分离接口和应用, 抽象类介于interface和普通类之间, 对于搭建那些仅有部分未实现方法的类很有用
2. Java的这两种方式在C++中没有直接支持, 可以看出其重要性

## 抽象类

1. 目的是发布公共接口, 因此抽象类无法创建对象, 这会在**编译时**提供一层保障
2. 抽象方法是不完整的方法, 仅包含方法声明, 含有抽象方法的类一定是抽象类, 抽象类也可以不含有任何抽象方法, 仅仅为了阻止创建对象
3. 如果继承抽象类, 则必须实现所有抽象方法, 如果不实现, 那么子类也必须是抽象类
4. 引入抽象类带来的两点好处:
   * 使用户和编译器明确该类是抽象的, 只能用于继承, 不能创建对象
   * 可以方便以后的修改, 比如创建通用方法

## interface(为了区分更加一般化的接口, 具体的接口用interface)

1. interface是完全版的抽象类, 不包含任何实现, 它像是在类之间发布了一种协议, 实现它的类都要遵守, 但interface不只是完全抽象类, 它使得多重继承变成可能, 也即一个类能够upcast到多种类型
2. interface和类在实现隐藏层面是同一级别的, 可以声明为public或package access, 声明为public时必须和文件名一致, 另外, interface中的域自动为static和final, 成员自动为public, 否则会在继承时丢失信息(因为自动变为package access)
3. interface的实现是显式的, 实现类中必须定义相应方法, 继承时如果不覆写, 相应方法被隐式定义, 这个道理也适用于抽象方法
4. 对已经实现interface的类, 再对其进行继承时, 其所有实现都被当作正常方法处理
5. interface和类的继承树各自独立, 不产生冲突
6. 在upcast的过程中, 并不能分辨出upcast的目标类型究竟是普通类, 抽象类, 还是interface, 相应的行为都是一致的
7. *strategy*设计模式是指一个依据传递给其的参数对象不同而拥有不同行为的方法, 方法是不变的部分, 参数用于传递不同的策略对象, 策略对象包含一段具体如何处理的代码, 这个策略对象一般是接口类型

### 完全分离

1. 目前为止, 接口与实现分离的两种主要办法一个是通过继承和多态, 另一个是通过interface, 第一种办法中外部应用父类引用的方法与整个继承体系的耦合度过高, 因为其他人编写的类可能同样适用于外部方法, 然而由于不在继承体系中, 不能被其所使用, interface的存在打破了原有各自独立的继承体系, 实现了完全的接口和其实现分离, 对interface编写通用的使用方法后, 所有实现接口的类(及其子类)都能应用于其中
2. 对于那些已经编写好的拥有独立的继承体系的类, 如果发现其适用于某个接口, 那么可以为其编写适配类, 用适配类实现接口, 同时在类中用代理实现接口方法, 如此一来便可以不用修改原有的代码, 便能轻松使用接口对应的通用方法

## Java中的多重继承

1. interface不占用存储空间(由于完全抽象, 其只占有静态存储区, 不能创建对象), 因此interface可以被多个类所实现, 同时一个类也可以实现多个interface, 后者即是多重继承
2. 对于一个类来说, 只能继承一个具体类或抽象类, 但可以实现多个interface
3. 使用interface的两点好处:
   * upcast到不止一个基类
   * 同抽象类, 阻止创建对象, 只发布接口
4. 如果能够创建接口, 一般接口优先于抽象类
5. *Diamond problem*:Java只允许对interface进行真正意义上的多重继承(即extends关键词), 对普通实现仅允许单一继承, C++中则需要在基类中添加额外的语法来消除歧义

### 用继承拓展接口

1. interface可用extends关键字进行拓展, 并且关键字后可跟不止一个interface

### 多重继承中的命名冲突

1. 如果类或interface中的方法名称相同, 在多重继承时有三种情况:
   * 方法参数表不同, 这时会产生重载, 注意如果不覆写在类中的非抽象方法, 会隐式重载
   * 方法返回值不同, 这时会报错
   * 名称, 参数表, 返回值都相同, 这时继承的方法实现了interface中的方法
2. 综上, 尽量避免多重继承中的重复命名

## 为interface适配(使用interface时最常用的两种设计模式)

1. *strategy pattern*再回顾: interface的一大好处就是可以有不同的实现, 在一个方法参数里使用interface类型的对象执行一些通用操作, 然后通过传递不同的实现对象来产生不同行为, 这样的方法更加灵活, 通用
2. *adapter pattern*: 如果有已经编写好的类, 并且想用该类实现特定interface的功能, 一个常见的做法是用接口类复用该类(可通过composition, delegation, 或inherit), 并实现相应interface, 在继承现有类并实现interface的情形下, interface相对于一般类的优势就体现了
3. Scanner类使用Readable接口类型作为参数, 因此既可以直接使用*strategy pattern*编写参数类, 也可用*adapter pattern*编写接口参数类, Readable接口只用实现一个read()方法, 此方法接受一个CharBuffer类型参数, 返回整型写入长度

## interface中的域

1. 隐含的static, final和public, 在Java SE5之前常被用做存储常量, 之后用enum类型会更好
2. 域不能当作blank final, 但可以执行方法对域动态初始化
3. 域的初始化发生在interface中的任意成员被访问时, 域不属于interface的一部分, 只是存储在interface的静态区域内

## interface的嵌套

1. 类内部interface可被声明为private, 并具有一些特点:
   * 该interface仅由该类可见, 可见性决定了实现interface的类必须在包含私有interface的类内部
   * 进一步考察"继承"可见性, 实现interface的类可以是private, 但同时也可以是public, 在public的情况下, 可以将其当成普通的内部类, interface里的方法(该类的实现版本)也可以使用
   * 如果内部interface类型由包含该interface的类方法所使用, 在外部时可以通过类相应对象调用方法来操作内部interface类型的对象
2. interface内部的interface只能为public(隐式自动提升), 这与原先的规定一致
3. 在内部的interface可以不必进行实现, 也即内外具有相互独立性

## interface与工厂方法设计模式

1. interface通常会有不同的实现, 为了描述每一种实现的通用创建过程, *Factory Method Pattern*将类的定义与相应对象的创建分离, 创造一种框架, 让用户端不必受限于具体的实现, 便于复用用户端的代码, 工厂interface与实现专门用来创建和返回相应的类对象(类与工厂类一一对应)
2. 最后忠告:普通类能满足需求就不要用接口

## 练习题

| 题号  | 描述                                                                           |
| :---: | ------------------------------------------------------------------------------ |
|   1   | 抽象类的接口与实现分离, 造成多态, *strategy pattern*一例                       |
|   2   | 抽象类无法创建对象                                                             |
|   3   | 抽象类的构造函数是不抽象的, 在里面调用多态方法同样会引起问题                   |
|   4   | 说明了抽象类的接口省去了downcast的麻烦                                         |
|   5   | interface的基本使用流程                                                        |
|   6   | interface内所有成员隐含public                                                  |
|   7   | interface的接口与实现分离, 造成多态, *strategy pattern*又一例                  |
|   8   | interface可以方便地嵌入原来的继承体系, 实现新功能的添加                        |
|   9   | 抽象类可以在原来的继承体系上小做改动, 就能把抽象方法提取出来                   |
|  10   | interface可以实现更细粒度的方法划分, 可为不同方法创建不同接口, 更加灵活        |
|  11   | *Adapter Pattern*一例, 也体现了一致返回值的便捷性                              |
|  12   | 体现interface添加新功能的便捷性                                                |
|  13   | 合并interface中的同名方法不会引起冲突, 而C++中则造成*Diamond Problem*          |
|  14   | 拓展interface及多重继承一例                                                    |
|  15   | 拓展interface及多重继承抽象类一例                                              |
|  16   | 为应用Scanner类, 实现Readable接口, 用到了*Adapter Pattern*                     |
|  17   | interface中的域是隐藏的static&final                                            |
|  18   | 承袭Polymorphism章节练习题5, interface + factory的框架适合于有新类要添加的情形 |
|  19   | 工厂方法又一例                                                                 |
