# Interfaces

1. interface和抽象类提供了更加结构化的方式来分离接口和应用, 抽象类介于interface和普通类之间, 对于搭建那些仅有部分未实现方法的类很有用
2. Java的这两种方式在C++中没有直接支持, 可以看出其重要性

## 抽象类

1. 目的是发布公共接口, 因此抽象类无法创建对象, 这会在**编译时**提供一层保障
2. 抽象方法是不完整的方法, 仅包含方法声明, 含有抽象方法的类一定是抽象类, 抽象类也可以不含有任何抽象方法, 仅仅为了阻止创建对象
3. 如果继承抽象类, 则必须实现所有抽象方法, 如果不实现, 那么子类也必须是抽象类
4. 引入抽象类带来的两点好处:
   * 使用户和编译器明确该类是抽象的, 只能用于继承, 不能创建对象
   * 可以方便以后的修改, 比如创建通用方法

## interface(为了区分更加一般化的接口, 具体的接口用interface)

1. interface是完全版的抽象类, 不包含任何实现, 它像是在类之间发布了一种协议, 实现它的类都要遵守, 但interface不只是完全抽象类, 它使得多重继承变成可能, 也即一个类能够upcast到多种类型
2. interface和类在实现隐藏层面是同一级别的, 可以声明为public或package access, 声明为public时必须和文件名一致, 另外, interface中的域自动为static和final, 方法自动为public, 否则会在继承时丢失信息(因为自动变为package access)
3. 对已经实现interface的类, 再对其进行继承时, 其所有实现都被当作正常方法处理
4. interface和类的继承树各自独立, 不产生冲突
5. 在upcast的过程中, 并不能分辨出upcast的目标类型究竟是普通类, 抽象类, 还是interface, 相应的行为都是一致的
6. *strategy*设计模式是指一个依据传递给其的参数对象不同而拥有不同行为的方法, 方法是不变的部分, 参数用于传递不同的策略对象, 策略对象包含一段具体如何处理的代码, 这个策略对象一般是接口类型

### 完全分离

1. 目前为止, 接口与实现分离的两种主要办法一个是通过继承和多态, 另一个是通过interface, 第一种办法中外部应用父类引用的方法与整个继承体系的耦合度过高, 因为其他人编写的类可能同样适用于外部方法, 然而由于不在继承体系中, 不能被其所使用, interface的存在打破了原有各自独立的继承体系, 实现了完全的接口和其实现分离, 对interface编写通用的使用方法后, 所有实现接口的类(及其子类)都能应用于其中
2. 对于那些已经编写好的拥有独立的继承体系的类, 如果发现其适用于某个接口, 那么可以为其编写适配类, 用适配类实现接口, 同时在类中用代理实现接口方法, 如此一来便可以不用修改原有的代码, 便能轻松使用接口对应的通用方法

## Java中的多重继承

1. interface不占用存储空间(由于完全抽象, 其只占有静态存储区, 不能创建对象), 因此interface可以被多个类所实现, 同时一个类也可以实现多个interface, 后者即是多重继承
2. 对于一个类来说, 只能继承一个具体类或抽象类, 但可以实现多个interface
3. 使用interface的两点好处:
   * upcast到不止一个基类
   * 同抽象类, 阻止创建对象, 只发布接口
4. 如果能够创建接口, 一般接口优先于抽象类

### 用继承拓展接口

1. interface可用extends关键字进行拓展, 并且关键字后可跟不止一个interface

### 多重继承中的命名冲突

1. 如果类或interface中的方法名称相同, 在多重继承时有两种情况:
   * 方法参数表不同, 这时会产生重载, 注意如果不覆写在类中的非抽象方法, 会隐式重载
   * 方法返回值不同, 这时会报错
2. 综上, 尽量避免多重继承中的重复命名

## 为interface适配

1. *strategy pattern*再回顾: interface的一大好处就是可以有不同的实现, 在一个方法参数里使用interface类型的对象执行一些通用操作, 然后通过传递不同的实现对象来产生不同行为, 这样的方法更加灵活, 通用
2. *adapter pattern*: 如果有已经编写好的类, 并且想用该类实现特定interface的功能, 一个常见的做法是用接口类复用该类(可通过composition, delegation, 或inherit), 并实现相应interface, 在继承现有类并实现interface的情形下, interface相对于一般类的优势就体现了

## interface中的域

1. 隐含的static, final和public, 在Java SE5之前常被用做存储常量, 之后用enum类型会更好
2. 域不能当作blank final, 但可以执行方法对域动态初始化
3. 域的初始化发生在interface中的任意成员被访问时, 域不属于interface的一部分, 只是存储在interface的静态区域内

## interface的嵌套

1. 类内部interface可被声明为private, 并具有一些特点:
   * 实现interface的类必须在包含私有interface的类内部
   * 实现interface的类可以是private, 但同时也可以是public, 在public的情况下, 对外不可提及此内部类实现interface的事实
   * 如果内部interface类型由包含该interface的类方法所使用, 在外部时可以通过类相应对象调用方法来操作内部interface类型的对象
2. interface内部的interface只能为public(隐藏自动提升), 这与原先的规定一致
3. 在内部的interface可以不必进行实现, 也即内外具有相互独立性

## interface与工厂设计模式

1. *factory pattern*: 将类的定义与相应对象的创建分离, 创造一种框架, 便于复用类的代码, 工厂interface与实现专门用来创建和返回相应的类对象(类与工厂类一一对应)
