# Initialization & Cleanup

## 构造函数, 方法重载, this关键字

### 构造函数

1. 对象的创建与构造函数的执行是一体的
2. 构造函数的命名很好地区分开了普通函数(首字母必定大写), 同时使得编译器能够自动识别
3. 构造函数一定无返回值, 一般方法可以自己定义为无返回值
4. 无构造函数时, 编译器会帮你自动生成默认构造函数, 定义了任意构造函数后, 编译器不会再自动生成

### 为何产生方法重载

1. 减少重复表达的需要
2. 由于构造函数名称固定, 因此需要重载来进行不同的初始化

### 如何区分重载的方法

1. 依靠其参数的种类, 数目和顺序

### 当使用基本类型作为重载方法参数时的一些注意点

1. 提供的参数类型较小时(不匹配已定义的参数类型), 一般自动升为高一级的类型
2. 常数自动升为`int`类型, `char`类型自动升为`int`类型(前提都是存在`int`对应的重载方法)
3. 提供的参数类型较大时, 必须cast才能被接受为合法参数

### this基本理解

1. 类中定义的每一个非静态方法都有一个隐含的参数, 指定其所操作的对象(仅这样理解)
2. 而this便提供了由隐含参数所指定的对象的一个引用(也即当前对象)

### 什么时候用this

1. 引用当前对象时
2. 将当前对象传递给另外一个方法时
3. 在构造函数里调用构造函数时
4. 域名与构造函数参数名冲突时, 消解歧义

### 在构造函数里调用构造函数

1. 用`this(args)`
2. 必须在开头
3. 只能用一次

### static再理解

1. 静态方法中没有this
2. 静态访问非静态的域或方法时, 必须依赖其引用(在此之前包含对象的创建)
3. 非静态方法访问静态的方法和域时无特殊限制

## Java清理的两大方面:finalization和垃圾收集

### finalize()

1. 由来:为了解决垃圾收集机制所不能释放的**内存**资源
2. 工作方式:当垃圾收集器准备好释放对象的内存时, 先调用finalize()方法, 然后在下一次的垃圾收集过程中收回对象所占用的内存
3. 总结用途:能够在进行垃圾收集的过程中实现一些重要的内存释放操作

### 三条原则

1. 并不是每个对象都会被垃圾收集机制所处理, 这取决于你的存储空间是否将要被用完, 没有被处理的对象所占用的内存最终将返回到操作系统
2. 垃圾收集不同于C++中的销毁, 在java中, 你需要自己完成额外的清理活动, 自己编写一个普通方法来进行内存的清理, 但finalize()方法并不靠谱
3. 垃圾收集仅关于内存资源, 所以finalize()方法同样也只能进行内存的释放, 这些内存是除了对象占用内存以外的内存(如:*native methods*)

### 你必须自己进行清理

1. 在C++中要么对象是本地对象(存在于栈中), 调用域结束后自动被释放, 要么是用new创建的对象 ,这些对象可以用delete来进行销毁(包含必要的清理工作和最后的内存释放)
2. java中没有本地对象, 只能用new来创建对象, 但同时java也没有delete, 因为垃圾收集器会自动清理内存, 但这里面有一个问题尚未解决:如果你想进行一些**非内存释放**的清理工作, 则必须由自己完成(在前面的讨论中, 已经说明finalize()不是解决办法)
3. 注意无论是finalization还是垃圾收集都不一定保证执行, 如果内存没有处于即将耗尽的情形下, JVM不会通过垃圾收集机制来回复内存

### finalize()的另一妙用:确认关闭状态

1. 关闭状态:是指当一个对象完成了所有预清理工作, 随时可以进行内存释放而不引起内存泄露的状态.(如:一个代表文件的对象在被垃圾收集之前要关闭文件以进入关闭状态)
2. finalize()在这里可以检查是否所有的预清理工作已经完成, 若没有完成则输出警告信息, 如果某一对象引发了垃圾收集并调用了finalize()方法则表明一些资源没有被正确关闭

### 垃圾收集器工作原理

1. 垃圾收集器可以加速堆对象分配的速度, 使之逼近栈对象的分配速度
2. C++堆类似花园, 为对象分配空间需要搜索内存寻找合适的区域, java堆类似于传送带, 每次完成内存分配后, 指针自动指向下一空闲区域
3. 最简单的垃圾收集机制是引用计数法, 当一个对象的引用个数降至0时即进行内存释放, 但这种方法无法解决引用环(两个对象互相引用)的问题
4. 更快的机制中, 垃圾收集是基于所有的存活对象最终都可以追溯到存在于栈或静态存储区域的引用之上, 反过来看, 从栈或静态区域中的引用出发, 遍历引用树, 最终能够找到所有的存活对象, 剩下的对象就可以被认为是非存活对象, 最终被垃圾收集器所处理
5. 在上述方法中, 如何对存活对象进行处理带来了一种适配性, 这里的方法之一是*stop-and-copy*, 这种方法首先暂停当前程序, 将当前堆中的对象复制到另一堆中, 剩下的非存活对象自然就被处理掉了, 复制时对象区域邻接, 新建堆的空间自然会更紧凑, 同时这种方法必须随之处理每个引用所指向的堆空间, 根据层序遍历的顺序, 每一层都可以停下来对引用进行修改(每一层的遍历都会产生一批新的地址间映射, 可以做成表, 方便修改)
6. 这种方法有两个问题:第一是需要两个堆, 也就意味着需要维护两倍的存储空间, 造成浪费, 解决办法是缩小粒度, 在存储块之间进行移动, 每个存储块保留一个*generation count*, 只有上一次垃圾收集过程中保留的存活块被认为是已压缩的, 第二个问题源于复制操作本身, 如果一个程序的垃圾比较少, 那么这种方法就将时间主要花在了复制存活对象上面, 效率自然就非常低下, 这时需要第二种适配方案来解决此问题
7. 方法之二叫做*mark-and-sweep*, 它寻找存活对象的步骤同方法一, 但每次仅仅对存活对象进行标记, 待此过程完成后, 再对剩余对象进行清理, 如果想对存活对象进行压缩, 必须另外进行重排, 值得注意的是, 尽管垃圾收集是一个低优先级的后台应用, 但在Sun公司早期的JVM实现中, 这两种方法都会暂停当前程序
8. JVM在不断监控垃圾收集的运行状态, 当内存中碎片增多, 则切换到*stop-and-copy*在存储块之间转移对象, 当存活对象大多变为长时间存活状态时, 切换到*mark-and-sweep*, 因此这种机制最终可称为"*Adaptive generational stop-and-copy mark-and-sweep*"
9. 其他加速JVM的方法：load过程中的just-in-time(JIT)编译器加*lazy evaluation*, Java HotSpot加速经常被执行的代码

## 成员初始化

1. 本地变量必须进行初始化, 否则会编译报错, 域变量即使不显式初始化, 也会被赋予默认值
2. 上述机制保证了变量一定能够得到初始化, 即使不进行下述各类初始化  

### 定义时初始化

1. 按定义的先后顺序初始化(原则一, 仅对变量有效)
2. 可以用方法初始化, 但方法参数必须在之前已经被初始化
3. 无论如何, 定义时初始化只能保证变量获得一个确定的值, 比较受限

### 使用构造函数初始化

1. 构造函数提供了在程序执行过程中进行不同初始化的能力, 赋予域变量不同的值
2. 定义时初始化与构造函数初始化相互独立, 因为初始化是被保证的, 在何处进行初始化完全取决于需求
3. 域变量初始化总是优先于对任意方法或构造函数的调用(原则二)

### 静态(域)变量的初始化

1. 本地变量不能被定义为静态, 因此静态变量特指静态域变量
2. 静态变量的初始化总是优先于非静态成员的初始化或引用
3. 注意访问静态成员和创建对象(构造函数是隐式静态方法)同样是两个相互独立的过程, 虽然他们都会引起静态变量的初始化
4. 静态变量初始化有且仅有一次(原则三, 三个原则的优先级依次升高)

### 实例初始化

1. 支持匿名内部类的初始化
2. 能够执行一些公共操作, 无论哪个构造函数被调用, 这个执行优先于构造函数调用
3. 在这个区域内仅进行操作, 所定义的变量为本地变量

### 初始化顺序总结(以class Dog为例)

1. 访问静态成员或创建对象引发java解释器搜索classpath找到Dog.class文件
2. 装载Dog.class, 并进行静态初始化(可以定义时初始化, 也可以在static块中初始化), 前两步的详情参见[typeinfo章节类字面常量部分]()
3. 如果没有创建对象, 则只进行前两个步骤, 如果`new Dog()`, 则先为对象在堆中分配空间
4. 把对象的空间清零(效果是域变量被赋予默认值)
5. 执行定义时初始化(这里可能包含实例初始化)
6. 执行构造函数初始化
7. 如果涉及继承, 整个过程会更加复杂, 主要体现在:
   * 第2步中会先对父类进行静态初始化(类的装载连接顺序应当是子类先于父类)
   * 第4步结束后, 会先初始化父类对象, 此时的父类对象已经能够进行多态方法调用

## 数组初始化

1. 定义数组引用使用格式`Type[] name;`
2. 要为数组对象分配空间, 则需要进行初始化, 这个初始化语句可能出现在任意位置, 只产生数组对象而不进一步对内部引用初始化则在内部引用被用到时触发异常
3. 如在定义时对数组对象进行初始化, 则可用{}的特殊格式
4. 数组对象包含一些只读信息, 如数组长度, java使用异常提供对数组越界的保护
5. 如果数组元素个数未知不能用{}的特殊语句初始化, 则可用new语句新建数组对象来进行初始化 ,虽然new不能创建基本类型, 但可以创建基本类型的数组
6. 数组对象的创建发生在运行时
7. 可以用`Array.toString()`方法来创建数组对象的可打印形式
8. 创建非基本类型的数组对象时, 有三种方法, 第一种是首先创建只包含引用的数组对象, 随后对数组对象内的引用进行初始化, 第二种是在定义时用{}的特殊格式进行初始化, 第三种结合前两种方法 ,用一个语句创建数组对象(new)并初始化数组对象内的所有对象({}格式), 这个语句可以不依赖数组引用, 使用在任意位置, 比如直接作为方法参数
9. autoboxing在数组对象是基本类型对应的类时会自动产生作用

## 变长参数表

1. 在Java SE5之前, 变长参数只能用数组实现, 如果定义Object类型的数组作为参数, 则可读取任意数目任意类型的参数, 但这种方法必须使用数组类型传参
2. Java SE5后可以用省略号来定义变长参数表, 用这种方法定义的参数表不仅可以识别逗号分隔的普通参数, 还可以直接使用一个数组作为参数表(不会进一步产生二维数组), 甚至可以不传递任何参数, 灵活性增强
3. 省略号定义的变长参数表实质上也是数组, 基本类型数组也同样原封不动, autoboxing的规则也依然自动适配
4. 变长参数表使得方法重载变得更加复杂, 尤其是有两个及以上的变长参数表重载形式的时候, 容易引起歧义, 从而导致编译报错, 因此建议一种函数要么只考虑一种变长参数形式, 要么不要使用

## 枚举类型

1. 注意命名用大写, 下划线分割单词
2. 枚举类型看似是新的数据类型, 其实就是类, 在定义和使用上大同小异
3. `toString()`产生打印形式, `ordinal()`表明定义顺序, `static values()`返回对应数组
4. enum尤其适用于switch语句
