# Generics

1. 考虑类型通用性的问题, 在泛型以前, 能够部分实现通用性的途径只有多态, 借助向上转型并编写针对父类的通用方法, 类型的限制变得宽松了, 甚至可以借助接口来打破不同继承体系的限制, 但是这种方法归根到底只能处理**特定**的一些类型, 这就需要泛型来处理那些涉及到**任意**类型的问题

## 简单泛型

1. 泛型的一大应用是实现容器类, 而对于容器类, 这里有三种思路:
   * generics/Holder1.java: 使用特定类型, 不能放入其他类型对象
   * generics/Holder2.java: 使用Object, 能放入任意类型对象, 但是仅能返回Object类型的引用
   * generics/Holder3.java: 加类型参数, 可以在定义容器时进行限制, 从而放入和返回的都是特定类型, 这里从结果看很像第一种, 主要的灵活性在于类型参数可指定

## 自制元组库

1. 元组是一个包含了多个任意类型对象的只读对象, 可作为返回值, 这种概念又可被称为数据交换对象(*Data Transfer Object 或 Messenger*)关键点有三:
   * 只读
   * 长度不定
   * 容纳的对象是任意类型
   
2. 如何实现上述的三个特性, 这里对应方法是:

   * 声明域为`final`, 但无需`private`, 会在编译时阻止二次赋值
   * 长度问题要创建不同长度的元组, 可通过继承简化
   * 通过泛型, 传入不同的类型参数

   如果想改变元组内容, 只能重新创建元组, 另外在创建元组时, `new`表达式略显冗长(把类型参数列表重复了一遍), 这个问题可通过后续定义泛型方法来解决

## 栈

1. net.mindview.util.Stark类使用组装的方式, 调用了LinkedList\<T>的原生方法来实现栈, generics/LinkedStack.java自行实现了栈的基本功能`push()`和`pop()`, 这里注意最初栈顶使用了一个"空节点"来作为末端哨兵(*end sentinel*)

## RandomList

1. generics/RandomList.java实现了从容器中随机选取对象的功能

## 练习题

| 题号 | 小节                      | 描述                                                         |
| ---- | ------------------------- | ------------------------------------------------------------ |
| 1    | [简单泛型](#简单泛型)     | 在类型参数确定以后, 泛型容器也能获得多态的便利               |
| 2    | [简单泛型](#简单泛型)     | 没什么特别的                                                 |
| 3    | [自制元组库](#自制元组库) | 定义一个六元组, 体会继承的简化作用                           |
| 4    | [自制元组库](#自制元组库) | 用泛型重新实现innerclasses/Sequence类, 注意类型参数没有应用在内部存储元素的数组上, 而是用在了添加(`add()`方法的参数)和取出(接口类型参数)元素的方法里 |
| 5    | [栈](#栈)                 | 非静态内部类能够获知外部类的类型参数                         |
| 6    | [RandomList](#RandomList) | 注意net.mindview.util.CountingGenerator的使用, 另外`dump()`的参数类型为RandomList<?> |
|      |                           |                                                              |
|      |                           |                                                              |
|      |                           |                                                              |
