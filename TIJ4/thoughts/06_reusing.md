# Rusing Classes

## 组装

1. 想要自动的String类型转换, 可以重写类的toString()方法
2. 可以打印值为null的引用而不引起exception
3. 编译器并不会自动创建对象, 要使引用绑定对象, 可在以下四个节点进行初始化:
   * 定义时, 发生在构造函数之前
   * 构造函数中
   * *lazy initialization*, 刚好在使用对象之前进行初始化, 这可以减少创建对象的开销, 尤其是对象的创建消耗较大的时候
   * *instance initialization*

## 继承

1. 可为不同的类都编写main()函数, 作为测试使用
2. 即使是package access的类, 其也能够被java命令执行public main()
3. 注意包内包外继承的区别, 包内继承能够访问拥有package access的成员, 而包外继承则不能, 因此对于继承而言, 需要对继承的成员声明为public或protected
4. 注意覆写方法时, 调用父类版本要用super, 否则会导致递归

### 父类的初始化

1. 继承采用自上而下的初始化, 依次调用构造函数(同时触发其它初始化), 父类的构造函数一定会被调用且一定在调用子类构造函数之前
2. 精确地说, 对父类对象的初始化(调用其构造函数), 发生在子类域初始化之前, 以及子类静态初始化之后

### 带参数的构造函数

1. 如果父类仅有带参数的构造函数, 需用super()显式调用, 并且必须在子类构造函数最前面

## 委托

1. 委托介于组装和继承之间, 首先它在该类内部创建了一个待用类的对象(组装), 同时它暴露了该对象的一部分成员(继承)
2. 委托比继承的控制权更大, 因为它可以仅暴露一部分的类成员

## 组装和继承的结合

1. 注意初始化组装的引用, 因为构造函数作为初始化的最后一道关口不能保证对其进行合理的初始化

### 合理的清除

1. 当需要对内存以外的内容进行清除时, 需要自定义清除方法, 不能依赖finalize()
2. 清除方法的调用顺序要严格和构造函数的初始化顺序相反
3. 清除方法应当放在try-finally的finally块中

### 继承中的方法重载

1. 对于继承的子类, 父类中的重载方法是完全可见的, 因此想要覆写父类中的重载方法时, 要加上@Override的注解, 防止该方法进一步重载

## 如何选择组装和继承

1. 对于组装, 可以创建私有对象, 这种情况下更关注该对象的功能, 而不是接口, 对外部来说, 仅仅看到的是被嵌入类的接口, 也可以创建公有对象, 这种情况下被嵌入类仅仅是各种嵌入类的一个组合, 在外部可以直接通过被嵌入类调用嵌入类的接口, 一般第一种情况比较普遍
2. 继承是*is-a*的关系, 在这一点上和组装(*has-a*)有着明显的区别, 也是使用继承的一个重要依据(一般情况下使用组装和委托, 除非继承是一种必须)
3. 如果存在upcast的需要, 则必须选择继承

## final关键字

1. 使用final关键字可能出于两种考虑:设计或效率

### final数据

1. 一般有两种情况需要定义常量:
   * 编译时常量, 无需再改变
   * 运行时常量, 在运行时被初始化, 而后无需再改变
2. 编译时常量可以在编译时就替换值, 因此能消除一些运行时开销, 这种常量要满足三个条件:
   * 基本类型
   * final关键字修饰
   * 在定义时即初始化
3. 如果数据被定义为static final, 则成为仅有一块存储空间的常量, 要用大写加下划线的格式书写变量名
4. 对于引用来说, 定义为final仅仅使得引用变为常量, 引用所指的对象可以随意改变, 对于数组类型来说, 道理相同, 可以这么理解, 定义为final的引用和对象就是一体的
5. final数据只能在定义时或构造函数中进行初始化, 这保证了它一定能够被初始化
6. 当final作为方法参数时, 如果参数是引用, 则不能改变引用, 如果参数是基本类型, 则只能读取其值, 这一点被用在了匿名内部类中

### final方法

1. final方法的声明应该只考虑是否防止方法被覆写, 而不考虑效率问题(带来的增益很小, 并且已经过时)
2. 私有方法默认为final因为无法被继承
3. 覆写只能作用于父类的接口方法, 对于父类的私有方法, 应当避免重名, 因为这不是覆写而仅仅是两个没有关联的方法

### final类

1. 在类层面阻止继承, 如果对类不想再做任何改动, 或是出于继承或引起安全问题的考虑, 可以使用final类
2. 等价于所有方法前面加final

### final的注意事项

1. 使用final要十分小心, Java历史上的Vector类本该让用户继承, 却将诸多方法声明为final, 极大地影响了代码可复用性
2. 有趣的是, Hashtable类便没有任何final方法, 这种不同的编码风格带来的不便再次强调了设计和代码复审的重要性

## 初始化与类装载

1. 像C++等语言, 所有的代码在全部装载后才开始初始化, 执行, 这会带来一个问题, 便是静态域的初始化依赖顺序必须十分小心
2. Java能够进行动态装载, 一个类只有在将要被使用时(某静态成员被访问), 才会触发该类的装载, 静态域的初始化依照代码顺序

### 引入继承后的初始化

1. 原先的初始化顺序只考虑单个类, 其可分为static初始化以及与创建对象相关的定义时初始化和构造函数两个阶段
2. 引入继承后, 同样分为这两个阶段, 但在每个阶段内, 按继承的顺序(自上而下)分别对类进行初始化(最开始装载的顺序是相反的, 自下而上, 但一开始下层的类并没有开始执行初始化)
