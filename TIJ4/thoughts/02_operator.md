# Operators

## side effect

1. 指操作符不仅从操作数中产生值, 并且会改变操作数的值
2. 除了赋值会产生side effect之外, 只有自增和自减产生side effect

## 操作符

1. 除了'=', '!=', '=='也可作用于对象之外, 所有的操作符要求操作数是基本类型
2. '+'和'+='可作用于String类型, 这里包含隐式类型转换

## 赋值

1. 赋值两要素, 注意左右操作数的不同
2. 给引用赋值时, 赋值实质是拷贝了引用, 出现对一个对象的多个引用, 这被称作'别名'
3. 方法传参的实质便是'别名', 并没有新对象的创建

## 关系运算符

1. 包括`!=, ==, > , >=, <, <=`六种
2. 除了'!='和'=='的四种关系运算符不作用于boolean类型
3. '!='和'=='作用于对象时只根据引用对象是否一致来判断, equals()方法底层调用了`==`, 如果引用所指对象相同时默认返回`true`, 也可以自行覆写该方法来判断内容是否一致, String和基本类型的包装类采用了覆写的方案, 可以比较内容是否相同
4. 上一点中注意"对象相同"是"内容相同"的充分不必要条件

## 逻辑运算符

1. 只能作用于boolean类型
2. 比较浮点数时, 关系运算符产生严格的结果
3. 逻辑表达式同样遵循'short circuit'

## 常数

1. 后缀大小写不敏感
2. 注意char, byte, short类型最大允许的二进制数, 超过则自动转为int, 需要cast才能进行对应赋值
3. 用Integer或Long类型的toBinaryString()方法打印二进制形式
4. 科学计数法常数中e表示10为底数

## 比特操作符

1. 可结合'='的三个是'^=', '&=', '|=', '~'不能结合
2. boolean比较特殊, 除了'~'以外其他三个可以对其进行处理, 但没有'short circuit'

## 移位运算符

1. 无符号右移用>>>
2. int类型只取5bit, long只取6bit, 保证不越界
3. short, byte会被先提升为int再进行位移, 因此可能会产生错误

## 类型转换

1. 基本类型除了boolean外都可以互相转换
2. 注意char, short, byte在进行数学或比特运算时都会有类型提升(这里注意一元操作符'-', '+')
3. 运算符和赋值的复合算符包含隐式类型转换

## overflow

1. 两int相加或相乘时可能会overflow而且不报错

## 练习题

| 题号  | 描述                                                                |
| :---: | ------------------------------------------------------------------- |
|   4   | 介绍了parseFloat()                                                  |
|   7   | nextBoolean()结合三目运算符实现掷硬币模拟, 查看doc中生成随机数的方法 |
|  14   | 用String类举例, 再次表明了'=='和'equals'的区别                       |
